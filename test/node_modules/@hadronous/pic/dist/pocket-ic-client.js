"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PocketIcClient = void 0;
const http_client_1 = require("./http-client");
const pocket_ic_client_types_1 = require("./pocket-ic-client-types");
const PROCESSING_TIME_HEADER = 'processing-timeout-ms';
const PROCESSING_TIME_VALUE_MS = 300_000;
const PROCESSING_HEADER = {
    [PROCESSING_TIME_HEADER]: PROCESSING_TIME_VALUE_MS.toString(),
};
class PocketIcClient {
    instanceUrl;
    serverUrl;
    topology;
    isInstanceDeleted = false;
    constructor(instanceUrl, serverUrl, topology) {
        this.instanceUrl = instanceUrl;
        this.serverUrl = serverUrl;
        this.topology = topology;
    }
    static async create(url, req) {
        const [instanceId, topology] = await PocketIcClient.createInstance(url, req);
        return new PocketIcClient(`${url}/instances/${instanceId}`, url, topology);
    }
    static async createInstance(url, req) {
        const res = await http_client_1.HttpClient.post(`${url}/instances`, { body: (0, pocket_ic_client_types_1.encodeCreateInstanceRequest)(req) });
        if ('Error' in res) {
            throw new Error(res.Error.message);
        }
        const topology = (0, pocket_ic_client_types_1.decodeInstanceTopology)(res.Created.topology);
        return [res.Created.instance_id, topology];
    }
    async deleteInstance() {
        this.assertInstanceNotDeleted();
        await fetch(this.instanceUrl, {
            method: 'DELETE',
        });
        this.isInstanceDeleted = true;
    }
    async tick() {
        this.assertInstanceNotDeleted();
        return await this.post('/update/tick');
    }
    async fetchRootKey() {
        this.assertInstanceNotDeleted();
        return await this.post('/read/pub_key');
    }
    getTopology() {
        return this.topology;
    }
    async getTime() {
        this.assertInstanceNotDeleted();
        const res = await this.get('/read/get_time');
        return (0, pocket_ic_client_types_1.decodeGetTimeResponse)(res);
    }
    async setTime(req) {
        this.assertInstanceNotDeleted();
        await this.post('/update/set_time', (0, pocket_ic_client_types_1.encodeSetTimeRequest)(req));
    }
    async getSubnetId(req) {
        this.assertInstanceNotDeleted();
        const res = await this.post('/read/get_subnet', (0, pocket_ic_client_types_1.encodeGetSubnetIdRequest)(req));
        return (0, pocket_ic_client_types_1.decodeGetSubnetIdResponse)(res);
    }
    async getCyclesBalance(req) {
        this.assertInstanceNotDeleted();
        const res = await this.post('/read/get_cycles', (0, pocket_ic_client_types_1.encodeGetCyclesBalanceRequest)(req));
        return (0, pocket_ic_client_types_1.decodeGetCyclesBalanceResponse)(res);
    }
    async addCycles(req) {
        this.assertInstanceNotDeleted();
        const res = await this.post('/update/add_cycles', (0, pocket_ic_client_types_1.encodeAddCyclesRequest)(req));
        return (0, pocket_ic_client_types_1.decodeAddCyclesResponse)(res);
    }
    async uploadBlob(req) {
        this.assertInstanceNotDeleted();
        const res = await fetch(`${this.serverUrl}/blobstore`, {
            method: 'POST',
            body: (0, pocket_ic_client_types_1.encodeUploadBlobRequest)(req),
        });
        return (0, pocket_ic_client_types_1.decodeUploadBlobResponse)(await res.text());
    }
    async setStableMemory(req) {
        this.assertInstanceNotDeleted();
        // this endpoint does not return JSON encoded responses,
        // so we make this request directly using fetch to avoid the automatic JSON decoding
        // from HttpClient.post
        const res = await fetch(`${this.instanceUrl}/update/set_stable_memory`, {
            method: 'POST',
            headers: {
                ...http_client_1.JSON_HEADER,
                ...PROCESSING_HEADER,
            },
            body: JSON.stringify((0, pocket_ic_client_types_1.encodeSetStableMemoryRequest)(req)),
        });
        (0, http_client_1.handleFetchError)(res);
    }
    async getStableMemory(req) {
        this.assertInstanceNotDeleted();
        const res = await this.post('/read/get_stable_memory', (0, pocket_ic_client_types_1.encodeGetStableMemoryRequest)(req));
        return (0, pocket_ic_client_types_1.decodeGetStableMemoryResponse)(res);
    }
    async updateCall(req) {
        this.assertInstanceNotDeleted();
        return await this.canisterCall('/update/execute_ingress_message', req);
    }
    async queryCall(req) {
        this.assertInstanceNotDeleted();
        return await this.canisterCall('/read/query', req);
    }
    async canisterCall(endpoint, req) {
        const res = await this.post(endpoint, (0, pocket_ic_client_types_1.encodeCanisterCallRequest)(req));
        return (0, pocket_ic_client_types_1.decodeCanisterCallResponse)(res);
    }
    async post(endpoint, body) {
        return await http_client_1.HttpClient.post(`${this.instanceUrl}${endpoint}`, {
            body,
            headers: PROCESSING_HEADER,
        });
    }
    async get(endpoint) {
        return await http_client_1.HttpClient.get(`${this.instanceUrl}${endpoint}`, {
            headers: PROCESSING_HEADER,
        });
    }
    assertInstanceNotDeleted() {
        if (this.isInstanceDeleted) {
            throw new Error('Instance was deleted');
        }
    }
}
exports.PocketIcClient = PocketIcClient;
//# sourceMappingURL=pocket-ic-client.js.map